import { chromeStorage } from '../services/chromeStorage.svelte';
import type { Settings } from '../../types/settings';

// Storage keys
const STORAGE_KEYS = {
  apiKey: 'sidenote_api_key',
  jinaApiKey: 'sidenote_jina_api_key',
  systemPrompt: 'sidenote_system_prompt',
  debugMode: 'sidenote_debug_mode',
  sheetUrl: 'sidenote_sheet_url',
  sheetName: 'sidenote_sheet_name',
  userBackground: 'sidenote_user_background',
  threadgirlPipelineUrl: 'sidenote_threadgirl_pipeline_url',
  threadgirlSheetUrl: 'sidenote_threadgirl_sheet_url',
  threadgirlSheetName: 'sidenote_threadgirl_sheet_name'
} as const;

// Models
export const MAVERICK_MODEL = 'meta-llama/llama-4-maverick-17b-128e-instruct';
export const SCOUT_MODEL = 'meta-llama/llama-4-scout-17b-16e-instruct';
export const MODEL = SCOUT_MODEL;

// Sections to filter out during extraction (case-insensitive matching)
export const SECTIONS_TO_FILTER = [
  'References',
  'Bibliography',
  'Citations',
  'Works Cited',
  'Literature Cited',
  'Appendix',
  'Supplementary Material',
  'Supplementary Information',
  'Supporting Information'
];

// Mandatory sections that should always be included if found, or noted if missing
export const MANDATORY_SECTIONS = [
  'Conflict of Interest',
  'Conflicts of Interest',
  'Competing Interests',
  'Financial Disclosures',
  'Disclosures'
];

// Synthetic sections that are generated by LLM analysis rather than extracted from existing headers
export const SYNTHETIC_SECTIONS = [
  'TL;DR',
  'Key Insights',
  'What\'s Next'
];

// Get environment variable if available (for development/testing)
function getEnvVar(key: string): string | undefined {
  // Check for Vite environment variables (build-time)
  if (typeof import.meta !== 'undefined' && import.meta.env) {
    return (import.meta.env as any)[`VITE_${key}`] || (import.meta.env as any)[key];
  }
  // Check for Node.js environment variables (build-time)
  if (typeof globalThis !== 'undefined' && (globalThis as any).process?.env) {
    return (globalThis as any).process.env[`VITE_${key}`] || (globalThis as any).process.env[key];
  }
  return undefined;
}

// Default settings
const DEFAULT_SETTINGS: Settings = {
  apiKey: '',
  jinaApiKey: '',
  systemPrompt: '',
  debugMode: true,
  sheetUrl: '',
  sheetName: '',
  userBackground: '',
  threadgirlPipelineUrl: '',
  threadgirlSheetUrl: '',
  threadgirlSheetName: 'Capsid Toolbox Prompts'
};

export class SettingsManager {
  settings = $state<Settings>({ ...DEFAULT_SETTINGS });
  isLoading = $state(false);
  isSaving = $state(false);
  saveStatus = $state<'idle' | 'saving' | 'saved' | 'error'>('idle');
  error = $state<string | null>(null);
  copyStatus = $state<'idle' | 'success' | 'error'>('idle');
  clearStatus = $state<'idle' | 'cleared' | 'error'>('idle');
  isCopyingStorage = $state(false);
  isCopyingRawStorage = $state(false);
  isCopyingSingleTab = $state(false);
  copiedMetadata: { totalTabs: number; totalSettings: number } | null = null;

  // Derived state using $derived
  isSaved = $derived(this.saveStatus === 'saved');
  hasApiKey = $derived(this.settings.apiKey.trim().length > 0);
  hasJinaApiKey = $derived(this.settings.jinaApiKey.trim().length > 0);

  private saveTimeout: number | null = null;

  constructor() {
    this.initialize();
  }

  private async initialize() {
    console.log('‚öôÔ∏è Initializing settings manager');
    await this.loadSettings();
  }

  private async loadSettings() {
    try {
      this.isLoading = true;
      this.error = null;

      // Load each setting from storage
      const promises = Object.entries(STORAGE_KEYS).map(async ([key, storageKey]) => {
        const value = await chromeStorage.get(storageKey);
        if (value !== undefined) {
          (this.settings as any)[key] = value;
        }
      });

      await Promise.all(promises);

      // Override with environment variables if available (for development)
      const envApiKey = getEnvVar('GROQ_API_KEY');
      if (envApiKey) {
        this.settings.apiKey = envApiKey;
      }

      const envJinaApiKey = getEnvVar('JINA_API_KEY');
      if (envJinaApiKey) {
        this.settings.jinaApiKey = envJinaApiKey;
      }

      console.log('‚öôÔ∏è Settings loaded successfully');
    } catch (error) {
      console.error('Failed to load settings:', error);
      this.error = error instanceof Error ? error.message : 'Failed to load settings';
    } finally {
      this.isLoading = false;
    }
  }

  // Update a single setting
  updateSetting<K extends keyof Settings>(key: K, value: Settings[K]) {
    this.settings[key] = value;
    this.scheduleSave();
  }

  // Update multiple settings
  updateSettings(updates: Partial<Settings>) {
    Object.assign(this.settings, updates);
    this.scheduleSave();
  }

  private scheduleSave() {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
    }

    this.saveTimeout = setTimeout(() => {
      this.saveSettings();
      this.saveTimeout = null;
    }, 1500) as unknown as number;
  }

  async saveSettings() {
    try {
      this.isSaving = true;
      this.saveStatus = 'saving';
      this.error = null;

      // Save each setting to storage
      const promises = Object.entries(STORAGE_KEYS).map(([key, storageKey]) => {
        const value = (this.settings as any)[key];
        return chromeStorage.set(storageKey, value);
      });

      await Promise.all(promises);

      this.saveStatus = 'saved';
      console.log('‚öôÔ∏è Settings saved successfully');

      // Reset save status after 2 seconds
      setTimeout(() => {
        if (this.saveStatus === 'saved') {
          this.saveStatus = 'idle';
        }
      }, 2000);

    } catch (error) {
      console.error('Failed to save settings:', error);
      this.error = error instanceof Error ? error.message : 'Failed to save settings';
      this.saveStatus = 'error';
    } finally {
      this.isSaving = false;
    }
  }

  async copyStorageData() {
    try {
      this.isCopyingStorage = true;
      this.copyStatus = 'idle';

      // Get all data directly from chrome.storage.local
      const allStorageData = await chrome.storage.local.get(null);

      // Separate tab data from settings
      const tabData: Record<string, any> = {};
      const settingsData: Record<string, any> = {};

      for (const [key, value] of Object.entries(allStorageData)) {
        if (key.startsWith('tabdata_')) {
          // Extract the URL from the key and use it as the key
          const url = key.replace('tabdata_', '');
          tabData[url] = value;
        } else if (key.startsWith('sidenote_')) {
          // Keep settings data
          settingsData[key] = value;
        } else {
          // Other data (might be from other extensions or legacy data)
          settingsData[key] = value;
        }
      }

      const totalTabs = Object.keys(tabData).length;
      const totalSettings = Object.keys(settingsData).length;

      // If we have too much data, create a summary instead of full export
      if (totalTabs > 100) {
        // Create a summary export with metadata and settings only
        const summaryData = {
          exportedAt: new Date().toISOString(),
          version: '1.0',
          type: 'summary',
          settingsData,
          tabSummary: Object.entries(tabData).map(([url, data]) => ({
            url,
            hasContent: !!(data as any)?.content?.extractedContent,
            hasSummary: !!(data as any)?.summary?.content,
            hasBookmark: !!(data as any)?.bookmark,
                         hasChat: !!((data as any)?.chat?.messages?.length > 0),
            lastUpdated: (data as any)?.lastUpdated || null
          })),
          metadata: {
            totalTabs,
            totalSettings,
            note: `Full data export skipped due to size (${totalTabs} tabs). This is a summary export. Contact support for full data export options.`
          }
        };

        const formattedData = JSON.stringify(summaryData, null, 2);
        await navigator.clipboard.writeText(formattedData);
        
        this.copyStatus = 'success';
        this.copiedMetadata = { totalTabs, totalSettings };
        console.log('üìã Summary data copied to clipboard (full data too large):', this.copiedMetadata);
      } else {
        // Small enough dataset - export everything
        const exportData = {
          exportedAt: new Date().toISOString(),
          version: '1.0',
          type: 'full',
          tabData,
          settingsData,
          metadata: {
            totalTabs,
            totalSettings
          }
        };

        // Try to stringify - if it fails, fall back to summary
        try {
          const formattedData = JSON.stringify(exportData, null, 2);
          await navigator.clipboard.writeText(formattedData);
          
          this.copyStatus = 'success';
          this.copiedMetadata = { totalTabs, totalSettings };
          console.log('üìã Full data copied to clipboard:', this.copiedMetadata);
        } catch (stringifyError) {
          console.warn('Full export failed, creating summary instead:', stringifyError);
          // Fall back to summary approach
          const summaryData = {
            exportedAt: new Date().toISOString(),
            version: '1.0',
            type: 'summary_fallback',
            settingsData,
            tabSummary: Object.entries(tabData).map(([url, data]) => ({
              url,
              hasContent: !!(data as any)?.content?.extractedContent,
              hasSummary: !!(data as any)?.summary?.content,
              hasBookmark: !!(data as any)?.bookmark,
              hasChat: !!((data as any)?.chat?.messages?.length > 0),
              lastUpdated: (data as any)?.lastUpdated || null
            })),
            metadata: {
              totalTabs,
              totalSettings,
              note: 'Full data export failed due to size. This is a summary export.'
            }
          };

          const summaryFormatted = JSON.stringify(summaryData, null, 2);
          await navigator.clipboard.writeText(summaryFormatted);
          
          this.copyStatus = 'success';
          this.copiedMetadata = { totalTabs, totalSettings };
          console.log('üìã Summary data copied to clipboard (fallback):', this.copiedMetadata);
        }
      }

      // Reset status after 5 seconds
      setTimeout(() => {
        this.copyStatus = 'idle';
        this.copiedMetadata = null;
      }, 5000);

    } catch (error) {
      console.error('Failed to copy all data:', error);
      this.copyStatus = 'error';
      
      // Reset status after 3 seconds
      setTimeout(() => {
        this.copyStatus = 'idle';
      }, 3000);
    } finally {
      this.isCopyingStorage = false;
    }
  }

  async copyRawStorageData() {
    try {
      this.isCopyingRawStorage = true;
      this.copyStatus = 'idle';

      // Get ALL data directly from chrome.storage.local - no processing
      const allStorageData = await chrome.storage.local.get(null);
      const allKeys = Object.keys(allStorageData);
      const totalItems = allKeys.length;

      console.log(`üìã Raw dump: ${totalItems} items found`);

      // If dataset is too large, create a sample + summary approach
      if (totalItems > 50) {
        // Take a sample of the first 10 items for structure inspection
        const sampleKeys = allKeys.slice(0, 10);
        const sampleData: Record<string, any> = {};
        
        sampleKeys.forEach(key => {
          sampleData[key] = allStorageData[key];
        });

        // Create summary of all keys
        const keysSummary = allKeys.map(key => ({
          key,
          type: key.startsWith('tabdata_') ? 'tab' : 
                key.startsWith('sidenote_') ? 'setting' : 'other',
          hasData: allStorageData[key] !== null && allStorageData[key] !== undefined,
          dataSize: JSON.stringify(allStorageData[key] || {}).length
        }));

        const exportData = {
          exportedAt: new Date().toISOString(),
          version: '1.0',
          type: 'raw_sample',
          totalItems,
          note: `Dataset too large (${totalItems} items). Showing first 10 items as sample + summary of all keys.`,
          sampleData,
          keysSummary,
          statistics: {
            totalTabs: allKeys.filter(k => k.startsWith('tabdata_')).length,
            totalSettings: allKeys.filter(k => k.startsWith('sidenote_')).length,
            totalOther: allKeys.filter(k => !k.startsWith('tabdata_') && !k.startsWith('sidenote_')).length
          }
        };

        const formattedData = JSON.stringify(exportData, null, 2);
        await navigator.clipboard.writeText(formattedData);
        
        this.copyStatus = 'success';
        this.copiedMetadata = { 
          totalTabs: exportData.statistics.totalTabs,
          totalSettings: exportData.statistics.totalSettings
        };
        console.log('üìã Raw sample data copied to clipboard:', this.copiedMetadata);
      } else {
        // Small dataset - export everything
        const rawExport = {
          exportedAt: new Date().toISOString(),
          version: '1.0',
          type: 'raw_dump_full',
          totalItems,
          data: allStorageData
        };

        const formattedData = JSON.stringify(rawExport, null, 2);
        await navigator.clipboard.writeText(formattedData);
        
        this.copyStatus = 'success';
        this.copiedMetadata = { 
          totalTabs: allKeys.filter(k => k.startsWith('tabdata_')).length,
          totalSettings: allKeys.filter(k => k.startsWith('sidenote_')).length
        };
        console.log('üìã Raw full data copied to clipboard:', this.copiedMetadata);
      }

      // Reset status after 5 seconds
      setTimeout(() => {
        this.copyStatus = 'idle';
        this.copiedMetadata = null;
      }, 5000);

    } catch (error) {
      console.error('Failed to copy raw storage data:', error);
      this.copyStatus = 'error';
      
      // Reset status after 3 seconds
      setTimeout(() => {
        this.copyStatus = 'idle';
      }, 3000);
    } finally {
      this.isCopyingRawStorage = false;
    }
  }

  async copySingleTabData(tabUrl?: string) {
    try {
      this.isCopyingSingleTab = true;
      this.copyStatus = 'idle';

      // Get all data to find available tabs
      const allStorageData = await chrome.storage.local.get(null);
      const tabKeys = Object.keys(allStorageData).filter(k => k.startsWith('tabdata_'));
      
      if (tabKeys.length === 0) {
        throw new Error('No tab data found');
      }

      // If no specific URL provided, get the first tab
      const targetKey = tabUrl ? `tabdata_${tabUrl}` : tabKeys[0];
      const tabData = allStorageData[targetKey];
      
      if (!tabData) {
        throw new Error(`No data found for tab: ${tabUrl || 'first available tab'}`);
      }

      const exportData = {
        exportedAt: new Date().toISOString(),
        version: '1.0',
        type: 'single_tab',
        tabUrl: targetKey.replace('tabdata_', ''),
        tabData,
        availableTabs: tabKeys.map(k => k.replace('tabdata_', '')).slice(0, 20), // Show first 20 available tabs
        totalAvailableTabs: tabKeys.length
      };

      const formattedData = JSON.stringify(exportData, null, 2);
      await navigator.clipboard.writeText(formattedData);
      
      this.copyStatus = 'success';
      this.copiedMetadata = { 
        totalTabs: 1,
        totalSettings: 0
      };
      console.log('üìã Single tab data copied to clipboard:', exportData.tabUrl);

      // Reset status after 5 seconds
      setTimeout(() => {
        this.copyStatus = 'idle';
        this.copiedMetadata = null;
      }, 5000);

    } catch (error) {
      console.error('Failed to copy single tab data:', error);
      this.copyStatus = 'error';
      
      // Reset status after 3 seconds
      setTimeout(() => {
        this.copyStatus = 'idle';
      }, 3000);
    } finally {
      this.isCopyingSingleTab = false;
    }
  }

  async clearTabData() {
    try {
      this.clearStatus = 'idle';
      
      // Clear all tab-specific data (keep settings)
      await chromeStorage.clearTabData();
      
      this.clearStatus = 'cleared';
      console.log('üóëÔ∏è Tab data cleared successfully');

      // Reset status after 3 seconds
      setTimeout(() => {
        this.clearStatus = 'idle';
      }, 3000);

    } catch (error) {
      console.error('Failed to clear tab data:', error);
      this.clearStatus = 'error';
      
      // Reset status after 3 seconds
      setTimeout(() => {
        this.clearStatus = 'idle';
      }, 3000);
    }
  }

  async reloadSettings() {
    await this.loadSettings();
  }

  cleanup() {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
      this.saveTimeout = null;
    }
  }
}

// Export a singleton instance
export const settingsManager = new SettingsManager();

// Helper function to get current settings synchronously
export function getCurrentSettings(): Settings {
  return settingsManager.settings;
} 