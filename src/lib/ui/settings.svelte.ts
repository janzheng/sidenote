import { chromeStorage } from '../services/chromeStorage';
import type { Settings } from '../../types/settings';

// Storage keys
const STORAGE_KEYS = {
  apiKey: 'sidenote_api_key',
  jinaApiKey: 'sidenote_jina_api_key',
  systemPrompt: 'sidenote_system_prompt',
  debugMode: 'sidenote_debug_mode',
  sheetUrl: 'sidenote_sheet_url',
  sheetName: 'sidenote_sheet_name',
  userBackground: 'sidenote_user_background'
} as const;

// Models
export const MAVERICK_MODEL = 'meta-llama/llama-4-maverick-17b-128e-instruct';
export const SCOUT_MODEL = 'meta-llama/llama-4-scout-17b-16e-instruct';
export const MODEL = SCOUT_MODEL;

// Sections to filter out during extraction (case-insensitive matching)
export const SECTIONS_TO_FILTER = [
  'References',
  'Bibliography',
  'Citations',
  'Works Cited',
  'Literature Cited',
  'Appendix',
  'Supplementary Material',
  'Supplementary Information',
  'Supporting Information'
];

// Mandatory sections that should always be included if found, or noted if missing
export const MANDATORY_SECTIONS = [
  'Conflict of Interest',
  'Conflicts of Interest',
  'Competing Interests',
  'Financial Disclosures',
  'Disclosures'
];

// Synthetic sections that are generated by LLM analysis rather than extracted from existing headers
export const SYNTHETIC_SECTIONS = [
  'TL;DR',
  'Key Insights',
  'What\'s Next'
];

// Get environment variable if available (for development/testing)
function getEnvVar(key: string): string | undefined {
  // Check for Vite environment variables (build-time)
  if (typeof import.meta !== 'undefined' && import.meta.env) {
    return (import.meta.env as any)[`VITE_${key}`] || (import.meta.env as any)[key];
  }
  // Check for Node.js environment variables (build-time)
  if (typeof globalThis !== 'undefined' && (globalThis as any).process?.env) {
    return (globalThis as any).process.env[`VITE_${key}`] || (globalThis as any).process.env[key];
  }
  return undefined;
}

// Default settings
const DEFAULT_SETTINGS: Settings = {
  apiKey: '',
  jinaApiKey: '',
  systemPrompt: '',
  debugMode: true,
  sheetUrl: '',
  sheetName: '',
  userBackground: ''
};

export class SettingsManager {
  // Reactive state using $state
  settings = $state<Settings>({ ...DEFAULT_SETTINGS });
  isLoading = $state(false);
  isSaving = $state(false);
  saveStatus = $state<'idle' | 'saving' | 'saved' | 'error'>('idle');
  error = $state<string | null>(null);
  copyStatus = $state<'idle' | 'success' | 'error'>('idle');
  clearStatus = $state<'idle' | 'cleared' | 'error'>('idle');
  isCopyingStorage = $state(false);

  // Derived state using $derived
  isSaved = $derived(this.saveStatus === 'saved');
  hasApiKey = $derived(this.settings.apiKey.trim().length > 0);
  hasJinaApiKey = $derived(this.settings.jinaApiKey.trim().length > 0);

  private saveTimeout: number | null = null;

  constructor() {
    this.initialize();
  }

  private async initialize() {
    console.log('‚öôÔ∏è Initializing settings manager');
    await this.loadSettings();
  }

  private async loadSettings() {
    try {
      this.isLoading = true;
      this.error = null;

      // Load each setting from storage
      const promises = Object.entries(STORAGE_KEYS).map(async ([key, storageKey]) => {
        const value = await chromeStorage.get(storageKey);
        if (value !== undefined) {
          (this.settings as any)[key] = value;
        }
      });

      await Promise.all(promises);

      // Override with environment variables if available (for development)
      const envApiKey = getEnvVar('GROQ_API_KEY');
      if (envApiKey) {
        this.settings.apiKey = envApiKey;
      }

      const envJinaApiKey = getEnvVar('JINA_API_KEY');
      if (envJinaApiKey) {
        this.settings.jinaApiKey = envJinaApiKey;
      }

      console.log('‚öôÔ∏è Settings loaded successfully');
    } catch (error) {
      console.error('Failed to load settings:', error);
      this.error = error instanceof Error ? error.message : 'Failed to load settings';
    } finally {
      this.isLoading = false;
    }
  }

  // Update a single setting
  updateSetting<K extends keyof Settings>(key: K, value: Settings[K]) {
    this.settings[key] = value;
    this.scheduleSave();
  }

  // Update multiple settings
  updateSettings(updates: Partial<Settings>) {
    Object.assign(this.settings, updates);
    this.scheduleSave();
  }

  private scheduleSave() {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
    }

    this.saveTimeout = setTimeout(() => {
      this.saveSettings();
      this.saveTimeout = null;
    }, 1500) as unknown as number;
  }

  async saveSettings() {
    try {
      this.isSaving = true;
      this.saveStatus = 'saving';
      this.error = null;

      // Save each setting to storage
      const promises = Object.entries(STORAGE_KEYS).map(([key, storageKey]) => {
        const value = (this.settings as any)[key];
        return chromeStorage.set(storageKey, value);
      });

      await Promise.all(promises);

      this.saveStatus = 'saved';
      console.log('‚öôÔ∏è Settings saved successfully');

      // Reset save status after 2 seconds
      setTimeout(() => {
        if (this.saveStatus === 'saved') {
          this.saveStatus = 'idle';
        }
      }, 2000);

    } catch (error) {
      console.error('Failed to save settings:', error);
      this.error = error instanceof Error ? error.message : 'Failed to save settings';
      this.saveStatus = 'error';
    } finally {
      this.isSaving = false;
    }
  }

  async copyStorageData() {
    try {
      this.isCopyingStorage = true;
      this.copyStatus = 'idle';

      // Get all storage data
      const allData = await chromeStorage.getAll();
      const formattedData = JSON.stringify(allData, null, 2);

      // Copy to clipboard
      await navigator.clipboard.writeText(formattedData);

      this.copyStatus = 'success';
      console.log('üìã Storage data copied to clipboard');

      // Reset status after 3 seconds
      setTimeout(() => {
        this.copyStatus = 'idle';
      }, 3000);

    } catch (error) {
      console.error('Failed to copy storage data:', error);
      this.copyStatus = 'error';
      
      // Reset status after 3 seconds
      setTimeout(() => {
        this.copyStatus = 'idle';
      }, 3000);
    } finally {
      this.isCopyingStorage = false;
    }
  }

  async clearTabData() {
    try {
      this.clearStatus = 'idle';
      
      // Clear all tab-specific data (keep settings)
      await chromeStorage.clearTabData();
      
      this.clearStatus = 'cleared';
      console.log('üóëÔ∏è Tab data cleared successfully');

      // Reset status after 3 seconds
      setTimeout(() => {
        this.clearStatus = 'idle';
      }, 3000);

    } catch (error) {
      console.error('Failed to clear tab data:', error);
      this.clearStatus = 'error';
      
      // Reset status after 3 seconds
      setTimeout(() => {
        this.clearStatus = 'idle';
      }, 3000);
    }
  }

  async reloadSettings() {
    await this.loadSettings();
  }

  cleanup() {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
      this.saveTimeout = null;
    }
  }
}

// Export a singleton instance
export const settingsManager = new SettingsManager();

// Helper function to get current settings synchronously
export function getCurrentSettings(): Settings {
  return settingsManager.settings;
} 