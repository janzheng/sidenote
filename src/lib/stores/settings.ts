import { writable, get } from 'svelte/store';
import { chromeStorage } from '../services/chromeStorage';

// Define types for settings
interface Settings {
  apiKey: string;
  jinaApiKey: string;
  // selectedModel: string;
  systemPrompt: string;
  debugMode: boolean;
  autoRefresh: boolean; // Renamed from autoLoad for clarity
  autoSave: boolean;
  sheetUrl: string;
  sheetName: string;
  userBackground: string; // Add userBackground to settings
}

// Default model
// const DEFAULT_MODEL = "meta-llama/llama-4-scout-17b-16e-instruct";

// Storage keys
const STORAGE_KEYS = {
  apiKey: 'sidenote_api_key',
  jinaApiKey: 'sidenote_jina_api_key',
  // selectedModel: 'sidenote_model',
  systemPrompt: 'sidenote_system_prompt',
  debugMode: 'sidenote_debug_mode',
  autoRefresh: 'sidenote_auto_refresh', // Renamed from autoLoad for clarity
  autoSave: 'sidenote_auto_save',
  sheetUrl: 'sidenote_sheet_url',
  sheetName: 'sidenote_sheet_name',
  userBackground: 'sidenote_user_background'
} as const;


// const MODEL = 'meta-llama/llama-4-maverick-17b-128e-instruct';
export const MAVERICK_MODEL = 'meta-llama/llama-4-maverick-17b-128e-instruct';
export const SCOUT_MODEL = 'meta-llama/llama-4-scout-17b-16e-instruct';
export const MODEL = SCOUT_MODEL;


// Sections to filter out during extraction (case-insensitive matching)
export const SECTIONS_TO_FILTER = [
  'References',
  'Bibliography',
  'Citations',
  'Works Cited',
  'Literature Cited',
  'Appendix',
  'Supplementary Material',
  'Supplementary Information',
  'Supporting Information'
];

// Mandatory sections that should always be included if found, or noted if missing
export const MANDATORY_SECTIONS = [
  'Conflict of Interest',
  'Conflicts of Interest',
  'Competing Interests',
  'Financial Disclosures',
  'Disclosures'
];

// Synthetic sections that are generated by LLM analysis rather than extracted from existing headers
export const SYNTHETIC_SECTIONS = [
  'TL;DR',
  'Key Insights',
  'What\'s Next'
];



// Get environment variable if available (for development/testing)
function getEnvVar(key: string): string | undefined {
  // Check for Vite environment variables (build-time)
  if (typeof import.meta !== 'undefined' && import.meta.env) {
    return (import.meta.env as any)[`VITE_${key}`] || (import.meta.env as any)[key];
  }
  // Check for Node.js environment variables (build-time)
  if (typeof globalThis !== 'undefined' && (globalThis as any).process?.env) {
    return (globalThis as any).process.env[`VITE_${key}`] || (globalThis as any).process.env[key];
  }
  return undefined;
}

// Initialize settings from chrome.storage or use defaults
async function loadInitialSettings(): Promise<Settings> {
  try {
    const keys = Object.values(STORAGE_KEYS);
    const stored = await chromeStorage.getMultiple(keys);
    
    // Check for environment variable as fallback for API key
    const envApiKey = getEnvVar('GROQ_API_KEY');
    const apiKey = stored[STORAGE_KEYS.apiKey] || envApiKey || '';
    
    // Check for environment variable as fallback for Jina API key
    const envJinaApiKey = getEnvVar('JINA_API_KEY');
    const jinaApiKey = stored[STORAGE_KEYS.jinaApiKey] || envJinaApiKey || '';
    
    if (envApiKey && !stored[STORAGE_KEYS.apiKey]) {
      console.log('ðŸ”‘ Using GROQ_API_KEY from environment variables for testing');
    }
    
    if (envJinaApiKey && !stored[STORAGE_KEYS.jinaApiKey]) {
      console.log('ðŸ”‘ Using JINA_API_KEY from environment variables for testing');
    }
    
    return {
      apiKey,
      jinaApiKey,
      // selectedModel: stored[STORAGE_KEYS.selectedModel] || DEFAULT_MODEL,
      systemPrompt: stored[STORAGE_KEYS.systemPrompt] || '',
      debugMode: stored[STORAGE_KEYS.debugMode] !== undefined ? stored[STORAGE_KEYS.debugMode] : true,
      autoRefresh: stored[STORAGE_KEYS.autoRefresh] !== undefined ? stored[STORAGE_KEYS.autoRefresh] : true, // Default to false
      autoSave: stored[STORAGE_KEYS.autoSave] !== undefined ? stored[STORAGE_KEYS.autoSave] : true, // Default to true
      sheetUrl: stored[STORAGE_KEYS.sheetUrl] || '',
      sheetName: stored[STORAGE_KEYS.sheetName] || '',
      userBackground: stored[STORAGE_KEYS.userBackground] || ''
    };
  } catch (error) {
    console.error('Error loading settings from chrome.storage:', error);
    
    // Still check for environment variable in error case
    const envApiKey = getEnvVar('GROQ_API_KEY');
    const envJinaApiKey = getEnvVar('JINA_API_KEY');
    if (envApiKey) {
      console.log('ðŸ”‘ Using GROQ_API_KEY from environment variables (fallback)');
    }
    if (envJinaApiKey) {
      console.log('ðŸ”‘ Using JINA_API_KEY from environment variables (fallback)');
    }
    
    return {
      apiKey: envApiKey || '',
      jinaApiKey: envJinaApiKey || '',
      // selectedModel: DEFAULT_MODEL,
      systemPrompt: '',
      debugMode: true,
      autoRefresh: false, // Default to false
      autoSave: true, // Default to true
      sheetUrl: '',
      sheetName: '',
      userBackground: ''
    };
  }
}

// Create a writable store with default values initially
const initialSettings: Settings = {
  apiKey: '',
  jinaApiKey: '',
  // selectedModel: DEFAULT_MODEL,
  systemPrompt: '',
  debugMode: true,
  autoRefresh: false, // Default to false
  autoSave: true, // Default to true
  sheetUrl: '',
  sheetName: '',
  userBackground: ''
};

export const settings = writable<Settings>(initialSettings);

// Load actual settings asynchronously
loadInitialSettings().then(loadedSettings => {
  settings.set(loadedSettings);
});

// Function to save settings
export async function saveSettings(newSettings: Settings): Promise<void> {
  try {
    settings.set(newSettings);
    
    const success = await chromeStorage.setMultiple({
      [STORAGE_KEYS.apiKey]: newSettings.apiKey,
      [STORAGE_KEYS.jinaApiKey]: newSettings.jinaApiKey,
      // [STORAGE_KEYS.selectedModel]: newSettings.selectedModel,
      [STORAGE_KEYS.systemPrompt]: newSettings.systemPrompt,
      [STORAGE_KEYS.debugMode]: newSettings.debugMode,
      [STORAGE_KEYS.autoRefresh]: newSettings.autoRefresh,
      [STORAGE_KEYS.autoSave]: newSettings.autoSave,
      [STORAGE_KEYS.sheetUrl]: newSettings.sheetUrl,
      [STORAGE_KEYS.sheetName]: newSettings.sheetName,
      [STORAGE_KEYS.userBackground]: newSettings.userBackground
    });
    
    if (!success) {
      console.error('Failed to save settings to chrome.storage');
    }
  } catch (error) {
    console.error('Error saving settings:', error);
  }
}

// Function to update individual settings
export async function updateSetting<K extends keyof Settings>(key: K, value: Settings[K]): Promise<void> {
  try {
    settings.update(current => {
      const updated = { ...current, [key]: value };
      
      // Persist to chrome.storage asynchronously
      const storageKey = STORAGE_KEYS[key];
      chromeStorage.set(storageKey, value).catch(error => {
        console.error(`Error saving setting ${key} to chrome.storage:`, error);
      });
      
      return updated;
    });
  } catch (error) {
    console.error(`Error updating setting ${key}:`, error);
  }
}

// Helper to get current settings synchronously
export function getCurrentSettings(): Settings {
  console.log('ðŸ”‘ Getting current settings:', get(settings));
  return get(settings);
}

// Helper to reload settings from storage
export async function reloadSettings(): Promise<void> {
  try {
    const loadedSettings = await loadInitialSettings();
    settings.set(loadedSettings);
  } catch (error) {
    console.error('Error reloading settings:', error);
  }
} 